/**
 * URL Monitoring App - Production Ready Version 4.0
 * Complete Background Service Implementation for Android
 * Features:
 * - Persistent background execution using react-native-background-actions
 * - Proper Android Doze mode handling
 * - Complete error recovery and retry logic
 * - Full lifecycle management
 * - Network state monitoring
 * - Batch URL checking with callbacks
 */

import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from 'react';
import {
  StatusBar,
  StyleSheet,
  useColorScheme,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  Switch,
  AppState,
  AppStateStatus,
  Platform,
  Modal,
  FlatList,
  PermissionsAndroid,
  BackHandler,
  Keyboard,
  RefreshControl,
} from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';
import DeviceInfo from 'react-native-device-info';
import AsyncStorage from '@react-native-async-storage/async-storage';
import BackgroundActions from 'react-native-background-actions';

// Constants
const STORAGE_KEYS = {
  URLS: '@NetGuard:urls',
  CALLBACK: '@NetGuard:callback',
  INTERVAL: '@NetGuard:checkInterval',
  LAST_CALLBACK: '@NetGuard:lastCallback',
  LAST_CHECK_TIME: '@NetGuard:lastCheckTime',
  AUTO_CHECK_ENABLED: '@NetGuard:autoCheckEnabled',
  NEXT_CHECK_TIME: '@NetGuard:nextCheckTime',
  API_ENDPOINT: '@NetGuard:apiEndpoint',
  BACKGROUND_STATS: '@NetGuard:backgroundStats',
  SERVICE_STATS: '@NetGuard:serviceStats',
  ERROR_LOGS: '@NetGuard:errorLogs',
  BG_LOGS: '@NetGuard:bgLogs',
};

const USER_AGENTS = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
];

const REQUEST_TIMEOUT = 30000;
const CALLBACK_TIMEOUT = 15000;
const MIN_INTERVAL_MINUTES = 1;
const MAX_INTERVAL_MINUTES = 1440;

// TypeScript interfaces
interface URLItem {
  id: string;
  url: string;
  lastChecked?: Date;
  status?: 'active' | 'inactive' | 'checking';
  checkHistory?: CheckRecord[];
  errorCount?: number;
  successCount?: number;
}

interface CheckRecord {
  timestamp: Date;
  status: 'active' | 'inactive';
  responseTime?: number;
  statusCode?: number;
  isRedirect?: boolean;
  errorType?: 'timeout' | 'network' | 'abort' | 'unknown';
  errorMessage?: string;
}

interface CallbackConfig {
  name: string;
  url: string;
}

interface CallbackHistory {
  timestamp: Date;
  urls: Array<{
    url: string;
    status: 'active' | 'inactive';
    error?: string;
  }>;
  success: boolean;
  totalUrls: number;
  activeCount: number;
  inactiveCount: number;
}

interface BackgroundServiceStats {
  isRunning: boolean;
  startTime: Date | null;
  totalChecks: number;
  lastCheckTime: Date | null;
  successfulCallbacks: number;
  failedCallbacks: number;
  errorMessage?: string;
}

interface DetailedCheckResult {
  status: 'active' | 'inactive';
  statusCode?: number;
  statusText?: string;
  isRedirect?: boolean;
  redirectUrl?: string;
  errorType?: 'timeout' | 'network' | 'abort' | 'unknown';
  errorMessage?: string;
}

// Helper Functions
const isDebugMode = () => __DEV__;

const bgLog = async (message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  const logMessage = `[BG ${timestamp}] ${message}`;

  if (isDebugMode()) {
    console.log(logMessage, data || '');
  }

  try {
    const logs = await AsyncStorage.getItem(STORAGE_KEYS.BG_LOGS);
    const parsedLogs = logs ? JSON.parse(logs) : [];
    parsedLogs.push({ timestamp, message, data });
    if (parsedLogs.length > 100) parsedLogs.shift();
    await AsyncStorage.setItem(STORAGE_KEYS.BG_LOGS, JSON.stringify(parsedLogs));
  } catch (error) {
    console.error('Failed to save bg log:', error);
  }
};

const logError = async (error: Error, context: string) => {
  console.error(`[${context}] Error:`, error.message);
  try {
    const errorLog = {
      context,
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
    };
    const existingLogs = await AsyncStorage.getItem(STORAGE_KEYS.ERROR_LOGS);
    const logs = existingLogs ? JSON.parse(existingLogs) : [];
    logs.push(errorLog);
    if (logs.length > 50) logs.shift();
    await AsyncStorage.setItem(STORAGE_KEYS.ERROR_LOGS, JSON.stringify(logs));
  } catch (logError) {
    console.error('Failed to log error:', logError);
  }
};

const randomSleep = (minSeconds: number = 0, maxSeconds: number = 30): Promise<void> => {
  const randomMs = (Math.random() * (maxSeconds - minSeconds) + minSeconds) * 1000;
  return new Promise(resolve => setTimeout(resolve, randomMs));
};

const getDeviceInfo = async () => {
  try {
    return {
      id: await DeviceInfo.getUniqueId(),
      model: DeviceInfo.getModel(),
      brand: DeviceInfo.getBrand(),
      platform: DeviceInfo.getSystemName(),
      version: DeviceInfo.getSystemVersion(),
    };
  } catch (error) {
    console.error('Error getting device info:', error);
    return {
      id: 'unknown',
      model: 'unknown',
      brand: 'unknown',
      platform: Platform.OS,
      version: 'unknown',
    };
  }
};

const checkNetworkInfo = async () => {
  try {
    let carrier = 'Unknown';
    let type = 'Unknown';
    let isConnected = true;

    try {
      carrier = await DeviceInfo.getCarrier();
      if (!carrier || carrier === 'unknown' || carrier === '--') {
        carrier = 'No SIM / WiFi Only';
      }
    } catch (error) {
      carrier = 'Detection Failed';
    }

    type = carrier === 'No SIM / WiFi Only' ? 'WiFi' : 'Mobile';

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      const response = await fetch('https://www.google.com/generate_204', {
        method: 'HEAD',
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      isConnected = response.ok || response.status === 204;
    } catch (error) {
      isConnected = false;
    }

    return { type, carrier, isConnected };
  } catch (error) {
    console.error('Error checking network info:', error);
    return { type: 'Unknown', carrier: 'Unknown', isConnected: false };
  }
};

const handlePermissions = async () => {
  if (Platform.OS === 'android') {
    try {
      const permissions = [];

      if (Platform.Version >= 33) {
        permissions.push(PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS);
      }

      if (permissions.length > 0) {
        await PermissionsAndroid.requestMultiple(permissions);
      }

      try {
        await PermissionsAndroid.request(
          'android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS' as any,
          {
            title: 'Background Activity Permission',
            message: 'NetGuard needs to run in background continuously.',
            buttonNeutral: 'Ask Me Later',
            buttonNegative: 'Cancel',
            buttonPositive: 'Allow',
          },
        );
      } catch (error) {
        console.log('Battery optimization permission error:', error);
      }
    } catch (err) {
      console.warn('Permission request error:', err);
    }
  }
};

const normalizeUrl = (url: string): string => {
  let normalized = url.trim();
  normalized = normalized.replace(/^\s+|\s+$/g, '');
  if (!normalized.match(/^https?:\/\//i)) {
    normalized = 'https://' + normalized;
  }
  normalized = normalized.replace(/\/+$/, '');
  return normalized;
};

const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return url.startsWith('http://') || url.startsWith('https://');
  } catch (error) {
    return false;
  }
};

const formatTimeAgo = (date: Date): string => {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSecs < 60) return `${diffSecs}s ago`;
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  return `${diffDays}d ago`;
};

const formatDateTime = (date: Date): string => {
  return date.toLocaleString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
};

// Background Task Implementation
const sleep = (time: number) => new Promise<void>((resolve) => setTimeout(() => resolve(), time));

const backgroundTask = async (taskDataArguments: any) => {
  await new Promise(async (resolve) => {
    const intervalMinutes = taskDataArguments?.delay || 60;
    const intervalMs = intervalMinutes * 60000;

    const performCheck = async () => {
      try {
        await bgLog('Starting background check cycle');

        const [savedUrls, savedCallback] = await Promise.all([
          AsyncStorage.getItem(STORAGE_KEYS.URLS),
          AsyncStorage.getItem(STORAGE_KEYS.CALLBACK),
        ]);

        if (!savedUrls) {
          await bgLog('No URLs configured');
          return;
        }

        const urls: URLItem[] = JSON.parse(savedUrls);
        const callbackConfig: CallbackConfig | null = savedCallback ? JSON.parse(savedCallback) : null;

        if (urls.length === 0) {
          await bgLog('Empty URL list');
          return;
        }

        const networkInfo = await checkNetworkInfo();
        if (!networkInfo.isConnected) {
          await bgLog('No network connection');
          return;
        }

        const checkResults = [];

        for (const urlItem of urls) {
          try {
            await randomSleep(2, 10);

            const userAgent = USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);

            const response = await fetch(urlItem.url, {
              method: 'GET',
              headers: {
                'User-Agent': userAgent,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
              },
              signal: controller.signal,
            });

            clearTimeout(timeoutId);

            const isSuccess = (response.status >= 200 && response.status < 400) ||
                            response.status === 401 || response.status === 403;

            checkResults.push({
              url: urlItem.url,
              status: isSuccess ? 'active' : 'inactive',
              statusCode: response.status,
            });

            await bgLog(`Checked ${urlItem.url}: ${response.status}`);
          } catch (error: any) {
            checkResults.push({
              url: urlItem.url,
              status: 'inactive',
              error: error.message,
            });
            await bgLog(`Failed ${urlItem.url}: ${error.message}`);
          }
        }

        // Send callback if configured
        if (callbackConfig?.url && checkResults.length > 0) {
          try {
            const payload = {
              checkType: 'background',
              timestamp: new Date().toISOString(),
              results: checkResults,
              network: networkInfo,
              device: await getDeviceInfo(),
            };

            const response = await fetch(callbackConfig.url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            await bgLog(`Callback sent: ${response.status}`);
          } catch (error: any) {
            await bgLog(`Callback failed: ${error.message}`);
          }
        }

        // Update stats
        const stats = await AsyncStorage.getItem(STORAGE_KEYS.BACKGROUND_STATS);
        const count = stats ? parseInt(stats, 10) + 1 : 1;
        await AsyncStorage.setItem(STORAGE_KEYS.BACKGROUND_STATS, count.toString());
        await AsyncStorage.setItem(STORAGE_KEYS.LAST_CHECK_TIME, new Date().toISOString());

      } catch (error: any) {
        await bgLog(`Background check error: ${error.message}`);
      }
    };

    // Keep running while the task is active
    while (BackgroundActions.isRunning()) {
      await performCheck();
      await sleep(intervalMs);
    }

    resolve(undefined);
  });
};

// Background task options
const backgroundOptions = {
  taskName: 'URL Monitor',
  taskTitle: 'üîç URL Monitor Active',
  taskDesc: 'Monitoring URLs in background',
  taskIcon: {
    name: 'ic_launcher',
    type: 'mipmap',
  },
  color: '#ff6600',
  linkingURI: 'netguard://monitor',
  parameters: {
    delay: 60,
  },
};

// Error Boundary Component
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Application Error:', error, errorInfo);
    logError(error, 'ErrorBoundary');
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorTitle}>‚ö†Ô∏è Something went wrong</Text>
          <Text style={styles.errorMessage}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </Text>
          <TouchableOpacity
            style={styles.errorButton}
            onPress={() => this.setState({ hasError: false, error: null })}
          >
            <Text style={styles.errorButtonText}>Restart App</Text>
          </TouchableOpacity>
        </View>
      );
    }
    return this.props.children;
  }
}

// Main App Component
function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    <ErrorBoundary>
      <SafeAreaProvider>
        <StatusBar
          barStyle={isDarkMode ? 'light-content' : 'dark-content'}
          backgroundColor={isDarkMode ? '#1a1a1a' : '#f5f5f5'}
        />
        <AppContent />
      </SafeAreaProvider>
    </ErrorBoundary>
  );
}

// Main App Content Component
function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();
  const isDarkMode = useColorScheme() === 'dark';
  const appState = useRef(AppState.currentState);

  // State management
  const [urls, setUrls] = useState<URLItem[]>([]);
  const [newUrl, setNewUrl] = useState('');
  const [callbackConfig, setCallbackConfig] = useState<CallbackConfig>({
    name: '',
    url: '',
  });
  const [checkInterval, setCheckInterval] = useState('60');
  const [isLoading, setIsLoading] = useState(false);
  const [networkInfo, setNetworkInfo] = useState({
    type: 'Unknown',
    carrier: 'Checking...',
    isConnected: true,
  });
  const [autoCheckEnabled, setAutoCheckEnabled] = useState(false);
  const [isBackgroundServiceRunning, setIsBackgroundServiceRunning] = useState(false);
  const [lastCheckTime, setLastCheckTime] = useState<Date | null>(null);
  const [backgroundCheckCount, setBackgroundCheckCount] = useState(0);
  const [refreshing, setRefreshing] = useState(false);

  // Load saved data on mount
  useEffect(() => {
    loadSavedData();
    checkNetworkInfo().then(setNetworkInfo);
    handlePermissions();

    // Check if background service is already running
    setIsBackgroundServiceRunning(BackgroundActions.isRunning());

    // App state listener
    const subscription = AppState.addEventListener('change', handleAppStateChange);

    // Android back button handler
    const backHandler = BackHandler.addEventListener('hardwareBackPress', () => {
      if (isBackgroundServiceRunning) {
        Alert.alert(
          'Background Service Running',
          'URL monitoring is active in background. Do you want to exit?',
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Exit', onPress: () => BackHandler.exitApp() },
          ],
        );
        return true;
      }
      return false;
    });

    return () => {
      subscription.remove();
      backHandler.remove();
    };
  }, []);

  const handleAppStateChange = (nextAppState: AppStateStatus) => {
    if (appState.current.match(/inactive|background/) && nextAppState === 'active') {
      loadSavedData();
      checkNetworkInfo().then(setNetworkInfo);
    }
    appState.current = nextAppState;
  };

  const loadSavedData = async () => {
    try {
      const [
        savedUrls,
        savedCallback,
        savedInterval,
        savedAutoCheck,
        savedLastCheck,
        savedBgCount,
      ] = await Promise.all([
        AsyncStorage.getItem(STORAGE_KEYS.URLS),
        AsyncStorage.getItem(STORAGE_KEYS.CALLBACK),
        AsyncStorage.getItem(STORAGE_KEYS.INTERVAL),
        AsyncStorage.getItem(STORAGE_KEYS.AUTO_CHECK_ENABLED),
        AsyncStorage.getItem(STORAGE_KEYS.LAST_CHECK_TIME),
        AsyncStorage.getItem(STORAGE_KEYS.BACKGROUND_STATS),
      ]);

      if (savedUrls) setUrls(JSON.parse(savedUrls));
      if (savedCallback) setCallbackConfig(JSON.parse(savedCallback));
      if (savedInterval) setCheckInterval(savedInterval);
      if (savedAutoCheck) setAutoCheckEnabled(JSON.parse(savedAutoCheck));
      if (savedLastCheck) setLastCheckTime(new Date(savedLastCheck));
      if (savedBgCount) setBackgroundCheckCount(parseInt(savedBgCount, 10));
    } catch (error) {
      console.error('Error loading saved data:', error);
    }
  };

  const saveUrls = async (newUrls: URLItem[]) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEYS.URLS, JSON.stringify(newUrls));
      setUrls(newUrls);
    } catch (error) {
      console.error('Error saving URLs:', error);
    }
  };

  const saveCallbackConfig = async (config: CallbackConfig) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEYS.CALLBACK, JSON.stringify(config));
      setCallbackConfig(config);
    } catch (error) {
      console.error('Error saving callback config:', error);
    }
  };

  const saveInterval = async (interval: string) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEYS.INTERVAL, interval);
      setCheckInterval(interval);
    } catch (error) {
      console.error('Error saving interval:', error);
    }
  };

  const addUrl = () => {
    if (!newUrl.trim()) {
      Alert.alert('Error', 'Please enter a URL');
      return;
    }

    const normalizedUrl = normalizeUrl(newUrl);
    if (!isValidUrl(normalizedUrl)) {
      Alert.alert('Error', 'Please enter a valid URL');
      return;
    }

    if (urls.some(u => u.url === normalizedUrl)) {
      Alert.alert('Error', 'This URL is already in the list');
      return;
    }

    const newUrlItem: URLItem = {
      id: Date.now().toString(),
      url: normalizedUrl,
      status: 'checking',
    };

    saveUrls([...urls, newUrlItem]);
    setNewUrl('');
    Keyboard.dismiss();
  };

  const removeUrl = (id: string) => {
    Alert.alert(
      'Remove URL',
      'Are you sure you want to remove this URL?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Remove',
          style: 'destructive',
          onPress: () => saveUrls(urls.filter(u => u.id !== id))
        },
      ],
    );
  };

  const checkSingleUrl = async (url: string): Promise<DetailedCheckResult> => {
    try {
      const userAgent = USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'User-Agent': userAgent,
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Cache-Control': 'no-cache',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      const isSuccess = (response.status >= 200 && response.status < 400) ||
                       response.status === 401 || response.status === 403;

      return {
        status: isSuccess ? 'active' : 'inactive',
        statusCode: response.status,
        statusText: response.statusText,
      };
    } catch (error: any) {
      let errorType: DetailedCheckResult['errorType'] = 'unknown';
      if (error.name === 'AbortError') errorType = 'timeout';
      else if (error.message.includes('Network')) errorType = 'network';

      return {
        status: 'inactive',
        errorType,
        errorMessage: error.message,
      };
    }
  };

  const checkAllUrls = async () => {
    if (urls.length === 0) {
      Alert.alert('No URLs', 'Please add URLs to monitor');
      return;
    }

    setIsLoading(true);
    const updatedUrls = urls.map(u => ({ ...u, status: 'checking' as const }));
    setUrls(updatedUrls);

    const results = [];
    for (const urlItem of updatedUrls) {
      const result = await checkSingleUrl(urlItem.url);
      const updatedUrl = {
        ...urlItem,
        status: result.status,
        lastChecked: new Date(),
      };
      results.push(updatedUrl);
      setUrls(prev => prev.map(u => u.id === urlItem.id ? updatedUrl : u));

      if (updatedUrls.indexOf(urlItem) < updatedUrls.length - 1) {
        await randomSleep(1, 3);
      }
    }

    await saveUrls(results);
    await AsyncStorage.setItem(STORAGE_KEYS.LAST_CHECK_TIME, new Date().toISOString());
    setLastCheckTime(new Date());

    // Send callback if configured
    if (callbackConfig.url) {
      try {
        const payload = {
          checkType: 'manual',
          timestamp: new Date().toISOString(),
          results: results.map(r => ({
            url: r.url,
            status: r.status,
          })),
          network: networkInfo,
          device: await getDeviceInfo(),
        };

        await fetch(callbackConfig.url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
      } catch (error) {
        console.error('Callback failed:', error);
      }
    }

    setIsLoading(false);
  };

  const toggleBackgroundService = async () => {
    if (!isBackgroundServiceRunning) {
      try {
        const interval = parseInt(checkInterval, 10);
        if (isNaN(interval) || interval < MIN_INTERVAL_MINUTES || interval > MAX_INTERVAL_MINUTES) {
          Alert.alert('Invalid Interval', `Please enter a value between ${MIN_INTERVAL_MINUTES} and ${MAX_INTERVAL_MINUTES} minutes`);
          return;
        }

        await saveInterval(checkInterval);
        await AsyncStorage.setItem(STORAGE_KEYS.AUTO_CHECK_ENABLED, 'true');

        const options = {
          ...backgroundOptions,
          parameters: { delay: interval },
        };

        await BackgroundActions.start(backgroundTask, options);
        setIsBackgroundServiceRunning(true);
        setAutoCheckEnabled(true);

        Alert.alert('Success', 'Background monitoring started');
      } catch (error: any) {
        console.error('Failed to start background service:', error);
        Alert.alert('Error', 'Failed to start background service: ' + error.message);
      }
    } else {
      try {
        await BackgroundActions.stop();
        setIsBackgroundServiceRunning(false);
        setAutoCheckEnabled(false);
        await AsyncStorage.setItem(STORAGE_KEYS.AUTO_CHECK_ENABLED, 'false');

        Alert.alert('Success', 'Background monitoring stopped');
      } catch (error: any) {
        console.error('Failed to stop background service:', error);
        Alert.alert('Error', 'Failed to stop background service: ' + error.message);
      }
    }
  };

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await loadSavedData();
    await checkNetworkInfo().then(setNetworkInfo);
    setRefreshing(false);
  }, []);

  const renderUrlItem = ({ item }: { item: URLItem }) => (
    <View style={[styles.urlItem, isDarkMode && styles.urlItemDark]}>
      <View style={styles.urlContent}>
        <Text style={[styles.urlText, isDarkMode && styles.urlTextDark]} numberOfLines={1}>
          {item.url}
        </Text>
        <View style={styles.urlMeta}>
          <View style={[
            styles.statusBadge,
            item.status === 'active' && styles.statusActive,
            item.status === 'inactive' && styles.statusInactive,
            item.status === 'checking' && styles.statusChecking,
          ]}>
            <Text style={styles.statusText}>
              {item.status === 'checking' ? 'Checking...' : item.status?.toUpperCase() || 'UNKNOWN'}
            </Text>
          </View>
          {item.lastChecked && (
            <Text style={[styles.lastChecked, isDarkMode && styles.lastCheckedDark]}>
              {formatTimeAgo(new Date(item.lastChecked))}
            </Text>
          )}
        </View>
      </View>
      <TouchableOpacity onPress={() => removeUrl(item.id)} style={styles.removeButton}>
        <Text style={styles.removeButtonText}>‚úï</Text>
      </TouchableOpacity>
    </View>
  );

  return (
    <View style={[styles.container, isDarkMode && styles.containerDark]}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={{ paddingBottom: safeAreaInsets.bottom + 20 }}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        <View style={[styles.header, { paddingTop: safeAreaInsets.top + 10 }]}>
          <Text style={[styles.title, isDarkMode && styles.titleDark]}>
            üîç NetGuard Monitor
          </Text>
          <Text style={[styles.subtitle, isDarkMode && styles.subtitleDark]}>
            URL Monitoring System
          </Text>
        </View>

        {/* Status Card */}
        <View style={[styles.card, isDarkMode && styles.cardDark]}>
          <Text style={[styles.cardTitle, isDarkMode && styles.cardTitleDark]}>
            üìä Service Status
          </Text>
          <View style={styles.statusRow}>
            <View
              style={[
                styles.statusIndicator,
                {
                  backgroundColor:
                    url.status === 'active'
                      ? '#4CAF50'
                      : url.status === 'inactive'
                      ? '#F44336'
                      : '#FFC107',
                },
              ]}
            />
            <Text style={[styles.statusText, textStyle]}>
              {url.status || 'Unknown'}
            </Text>
            {url.lastChecked && (
              <Text style={[styles.lastCheckedText, textStyle]}>
                {` ‚Ä¢ ${formatTimeAgo(url.lastChecked)}`}
              </Text>
            )}
          </View>

          {/* Display additional information */}
          {url.checkHistory && url.checkHistory.length > 0 && (
            <>
              <Text style={[styles.responseTimeText, textStyle]}>
                Response:{' '}
                {
                  url.checkHistory[url.checkHistory.length - 1]
                    .responseTime
                }
                ms
                {url.checkHistory[url.checkHistory.length - 1]
                  .statusCode &&
                  ` ‚Ä¢ Status: ${
                    url.checkHistory[url.checkHistory.length - 1]
                      .statusCode
                  }`}
              </Text>
              {url.checkHistory[url.checkHistory.length - 1]
                .isRedirect && (
                <Text style={[styles.redirectText, textStyle]}>
                  ‚Ü™ Redirected
                </Text>
              )}
              {url.checkHistory[url.checkHistory.length - 1]
                .errorMessage && (
                <Text style={[styles.errorText, { color: '#F44336' }]}>
                  ‚ö†{' '}
                  {
                    url.checkHistory[url.checkHistory.length - 1]
                      .errorMessage
                  }
                </Text>
              )}
            </>
          )}
        </View>
        <TouchableOpacity onPress={() => removeUrl(url.id)}>
          <Text style={styles.removeText}>Remove</Text>
        </TouchableOpacity>
      </View>
    ))}

    {urls.length === 0 && (
      <Text style={[styles.emptyText, textStyle]}>No URLs added yet</Text>
    )}
  </View>

  {/* Callback Configuration */}
  <View style={cardStyle}>
    <Text style={[styles.sectionTitle, textStyle]}>
      Callback Configuration
    </Text>
    <TextInput
      style={inputStyle}
      placeholder="Callback Name"
      placeholderTextColor={isDarkMode ? '#999' : '#666'}
      value={callbackConfig.name}
      onChangeText={text =>
        setCallbackConfig(prev => ({ ...prev, name: text }))
      }
    />
    <TextInput
      style={[inputStyle, styles.marginTop]}
      placeholder="Callback URL (e.g. webhook.site/...)"
      placeholderTextColor={isDarkMode ? '#999' : '#666'}
      value={callbackConfig.url}
      onChangeText={text =>
        setCallbackConfig(prev => ({ ...prev, url: text }))
      }
      autoCapitalize="none"
      autoCorrect={false}
    />
    <TouchableOpacity
      style={[styles.button, styles.marginTop]}
      onPress={saveCallbackConfig}
    >
      <Text style={styles.buttonText}>Save Callback</Text>
    </TouchableOpacity>

    {/* Last Callback Info */}
    {lastCallback && (
      <View style={styles.callbackHistory}>
        <Text style={[styles.callbackHistoryTitle, textStyle]}>
          Last Callback:
        </Text>
        <Text style={[styles.callbackHistoryText, textStyle]}>
          Time: {formatDateTime(lastCallback.timestamp)}
        </Text>
        <Text style={[styles.callbackHistoryText, textStyle]}>
          Total URLs: {lastCallback.totalUrls} (
          <Text style={{ color: '#4CAF50', fontWeight: 'bold' }}>
            {lastCallback.activeCount} active
          </Text>
          ,{' '}
          <Text style={{ color: '#F44336', fontWeight: 'bold' }}>
            {lastCallback.inactiveCount} inactive
          </Text>
          )
        </Text>
        <Text style={[styles.callbackHistoryText, textStyle]}>
          Sent:{' '}
          <Text
            style={{
              color: lastCallback.success ? '#4CAF50' : '#F44336',
              fontWeight: 'bold',
            }}
          >
            {lastCallback.success ? 'Success' : 'Failed'}
          </Text>
        </Text>

        {/* Show all URLs in last callback */}
        <View style={styles.urlListContainer}>
          <Text style={[styles.urlListTitle, textStyle]}>URLs:</Text>
          {lastCallback.urls.map((urlInfo, index) => (
            <View key={index} style={styles.urlListItem}>
              <View
                style={[
                  styles.urlListIndicator,
                  {
                    backgroundColor:
                      urlInfo.status === 'active' ? '#4CAF50' : '#F44336',
                  },
                ]}
              />
              <Text
                style={[styles.urlListText, textStyle]}
                numberOfLines={1}
              >
                {urlInfo.url}
              </Text>
              {urlInfo.error && (
                <Text style={[styles.urlErrorText, { color: '#F44336' }]}>
                  ({urlInfo.error})
                </Text>
              )}
            </View>
          ))}
        </View>
      </View>
    )}
  </View>

  {/* Check Interval Settings */}
  <View style={cardStyle}>
    <Text style={[styles.sectionTitle, textStyle]}>
      Check Interval Settings
    </Text>

    <View style={styles.inputRow}>
      <TextInput
        style={[inputStyle, styles.intervalInput]}
        placeholder="Interval (minutes)"
        placeholderTextColor={isDarkMode ? '#999' : '#666'}
        value={checkInterval}
        onChangeText={setCheckInterval}
        keyboardType="numeric"
      />
      <TouchableOpacity style={styles.button} onPress={saveInterval}>
        <Text style={styles.buttonText}>Set Interval</Text>
      </TouchableOpacity>
    </View>

    {/* Background Service Tips for Android */}
    {Platform.OS === 'android' && (
      <View style={styles.androidTips}>
        <Text style={[styles.androidTipsTitle, textStyle]}>
          üí° Background Service Tips:
        </Text>
        <Text style={[styles.androidTipsText, textStyle]}>
          ‚Ä¢ Grant all permissions when prompted
        </Text>
        <Text style={[styles.androidTipsText, textStyle]}>
          ‚Ä¢ Disable battery optimization in Settings
        </Text>
        <Text style={[styles.androidTipsText, textStyle]}>
          ‚Ä¢ Lock app in Recent Apps (swipe & tap lock icon)
        </Text>
        <Text style={[styles.androidTipsText, textStyle]}>
          ‚Ä¢ Keep persistent notification visible
        </Text>
      </View>
    )}
  </View>

  {/* Manual Check Button */}
  <TouchableOpacity
    style={[styles.checkButton, isLoading && styles.buttonDisabled]}
    onPress={() => checkAllUrls(false)}
    disabled={isLoading || urls.length === 0}
  >
    {isLoading ? (
      <ActivityIndicator color="white" />
    ) : (
      <Text style={styles.checkButtonText}>Check All URLs Now</Text>
    )}
  </TouchableOpacity>

  {/* Info Note */}
  <View style={styles.infoNote}>
    <Text style={[styles.infoNoteText, textStyle]}>
      ‚ÑπÔ∏è NetGuard Pro uses react-native-background-actions for true
      background monitoring.
      {'\n\n'}
      üîÑ Background service runs independently from the app
      {'\n'}
      üì± Persistent notification shows service status
      {'\n'}
      üîã Optimized for battery efficiency
      {'\n'}
      üì° Works even when app is closed or device is locked
    </Text>
  </View>
</View>

{/* API Callback Selection Modal */}
<Modal
  visible={showAPIModal}
  animationType="slide"
  transparent={true}
  onRequestClose={() => setShowAPIModal(false)}
>
  <View style={styles.modalOverlay}>
    <View
      style={[
        styles.modalContent,
        { backgroundColor: isDarkMode ? '#2a2a2a' : 'white' },
      ]}
    >
      <Text style={[styles.modalTitle, textStyle]}>Select Callback</Text>

      <FlatList
        data={apiCallbackNames}
        keyExtractor={item => item}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={styles.modalItem}
            onPress={() => loadURLsForCallback(item)}
          >
            <Text style={[styles.modalItemText, textStyle]}>{item}</Text>
            <Text style={[styles.modalItemCount, textStyle]}>
              {apiData.filter(d => d.callback_name === item).length} URLs
            </Text>
          </TouchableOpacity>
        )}
        style={styles.modalList}
      />

      <TouchableOpacity
        style={styles.modalCloseButton}
        onPress={() => setShowAPIModal(false)}
      >
        <Text style={styles.modalCloseButtonText}>Cancel</Text>
      </TouchableOpacity>
    </View>
  </View>
</Modal>
</ScrollView>
);
}

const styles = StyleSheet.create({
container: {
flex: 1,
},
content: {
padding: 16,
paddingBottom: 32,
},
header: {
alignItems: 'center',
marginBottom: 20,
},
title: {
fontSize: 28,
fontWeight: 'bold',
},
lastCheckText: {
fontSize: 12,
opacity: 0.7,
marginTop: 4,
},
backgroundStatsText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
color: '#2196F3',
},
card: {
borderRadius: 12,
padding: 16,
marginBottom: 16,
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.1,
shadowRadius: 3.84,
elevation: 5,
},
serviceActiveCard: {
backgroundColor: '#E8F5E9',
borderColor: '#4CAF50',
borderWidth: 1,
},
serviceInactiveCard: {
backgroundColor: '#FFEBEE',
borderColor: '#F44336',
borderWidth: 1,
},
serviceHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 8,
},
serviceTitle: {
fontSize: 16,
fontWeight: '600',
flex: 1,
},
serviceDescription: {
fontSize: 14,
opacity: 0.8,
marginBottom: 4,
},
serviceUptime: {
fontSize: 12,
opacity: 0.7,
marginBottom: 4,
},
countdownText: {
fontSize: 14,
fontWeight: 'bold',
color: '#2196F3',
},
statsGrid: {
flexDirection: 'row',
justifyContent: 'space-around',
marginTop: 12,
},
statItem: {
alignItems: 'center',
},
statValue: {
fontSize: 20,
fontWeight: 'bold',
},
statLabel: {
fontSize: 12,
opacity: 0.7,
marginTop: 4,
},
lastServiceCheck: {
fontSize: 12,
opacity: 0.7,
marginTop: 8,
textAlign: 'center',
},
sectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 12,
},
sectionTitle: {
fontSize: 18,
fontWeight: '600',
},
clearText: {
color: '#F44336',
fontSize: 14,
fontWeight: '600',
},
networkInfoContainer: {
marginBottom: 12,
},
networkRow: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 8,
},
networkLabel: {
fontSize: 14,
fontWeight: '500',
width: 80,
},
networkValue: {
fontSize: 16,
fontWeight: '600',
flex: 1,
},
connectionStatus: {
flexDirection: 'row',
alignItems: 'center',
},
connectionIndicator: {
width: 10,
height: 10,
borderRadius: 5,
marginRight: 8,
},
refreshButton: {
backgroundColor: '#2196F3',
paddingHorizontal: 16,
paddingVertical: 8,
borderRadius: 6,
alignSelf: 'flex-start',
},
refreshButtonText: {
color: 'white',
fontSize: 14,
fontWeight: '600',
},
input: {
borderRadius: 8,
padding: 12,
fontSize: 16,
},
inputRow: {
flexDirection: 'row',
alignItems: 'center',
},
urlInput: {
flex: 1,
marginRight: 8,
},
intervalInput: {
flex: 1,
marginRight: 8,
},
addButton: {
backgroundColor: '#2196F3',
paddingHorizontal: 20,
paddingVertical: 12,
borderRadius: 8,
},
button: {
backgroundColor: '#4CAF50',
paddingHorizontal: 20,
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
},
buttonText: {
color: 'white',
fontWeight: '600',
fontSize: 16,
},
checkButton: {
backgroundColor: '#FF9800',
padding: 16,
borderRadius: 12,
alignItems: 'center',
marginTop: 20,
},
checkButtonText: {
color: 'white',
fontWeight: 'bold',
fontSize: 18,
},
buttonDisabled: {
opacity: 0.6,
},
urlItem: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
paddingVertical: 12,
borderBottomWidth: 1,
borderBottomColor: '#e0e0e0',
},
urlInfo: {
flex: 1,
marginRight: 12,
},
urlText: {
fontSize: 14,
marginBottom: 4,
},
statusRow: {
flexDirection: 'row',
alignItems: 'center',
},
statusIndicator: {
width: 8,
height: 8,
borderRadius: 4,
marginRight: 6,
},
statusText: {
fontSize: 12,
textTransform: 'capitalize',
},
lastCheckedText: {
fontSize: 11,
opacity: 0.7,
},
responseTimeText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
},
redirectText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
color: '#FF9800',
},
errorText: {
fontSize: 11,
marginTop: 2,
},
removeText: {
color: '#F44336',
fontSize: 14,
fontWeight: '600',
},
emptyText: {
textAlign: 'center',
marginVertical: 20,
opacity: 0.6,
},
marginTop: {
marginTop: 12,
},
callbackHistory: {
marginTop: 16,
padding: 12,
backgroundColor: 'rgba(0,0,0,0.05)',
borderRadius: 8,
},
callbackHistoryTitle: {
fontSize: 14,
fontWeight: '600',
marginBottom: 4,
},
callbackHistoryText: {
fontSize: 12,
marginBottom: 2,
},
urlListContainer: {
marginTop: 8,
paddingTop: 8,
borderTopWidth: 1,
borderTopColor: 'rgba(0,0,0,0.1)',
},
urlListTitle: {
fontSize: 12,
fontWeight: '600',
marginBottom: 4,
},
urlListItem: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 2,
paddingVertical: 2,
},
urlListIndicator: {
width: 6,
height: 6,
borderRadius: 3,
marginRight: 6,
},
urlListText: {
fontSize: 11,
flex: 1,
},
urlErrorText: {
fontSize: 10,
marginLeft: 4,
},
androidTips: {
marginTop: 12,
padding: 10,
backgroundColor: 'rgba(33, 150, 243, 0.1)',
borderRadius: 8,
},
androidTipsTitle: {
fontSize: 14,
fontWeight: '600',
marginBottom: 4,
},
androidTipsText: {
fontSize: 12,
opacity: 0.8,
marginLeft: 12,
marginTop: 2,
},
infoNote: {
marginTop: 20,
padding: 12,
backgroundColor: 'rgba(33, 150, 243, 0.1)',
borderRadius: 8,
},
infoNoteText: {
fontSize: 12,
textAlign: 'center',
opacity: 0.8,
lineHeight: 18,
},
apiButtonsRow: {
flexDirection: 'row',
marginTop: 12,
gap: 8,
},
apiButton: {
backgroundColor: '#9C27B0',
paddingHorizontal: 16,
paddingVertical: 10,
borderRadius: 8,
flex: 1,
alignItems: 'center',
},
selectedCallbackText: {
fontSize: 14,
marginTop: 8,
fontStyle: 'italic',
},
modalOverlay: {
flex: 1,
backgroundColor: 'rgba(0, 0, 0, 0.5)',
justifyContent: 'center',
alignItems: 'center',
},
modalContent: {
width: '90%',
maxHeight: '70%',
borderRadius: 12,
padding: 20,
elevation: 5,
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.25,
shadowRadius: 3.84,
},
modalTitle: {
fontSize: 20,
fontWeight: 'bold',
marginBottom: 16,
textAlign: 'center',
},
modalList: {
maxHeight: 400,
},
modalItem: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
paddingVertical: 12,
paddingHorizontal: 16,
borderBottomWidth: 1,
borderBottomColor: 'rgba(0, 0, 0, 0.1)',
},
modalItemText: {
fontSize: 16,
flex: 1,
},
modalItemCount: {
fontSize: 14,
opacity: 0.6,
marginLeft: 8,
},
modalCloseButton: {
marginTop: 16,
backgroundColor: '#F44336',
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
},
modalCloseButtonText: {
color: 'white',
fontSize: 16,
fontWeight: '600',
},
});

export default App;

<View style={styles.statusRow}>
  <View
    style={[
      styles.statusIndicator,
      {
        backgroundColor:
          url.status === 'active'
            ? '#4CAF50'
            : url.status === 'inactive'
            ? '#F44336'
            : '#FFC107',
      },
    ]}
  />
  <Text style={[styles.statusText, textStyle]}>
    {url.status || 'Unknown'}
  </Text>
  {url.lastChecked && (
    <Text style={[styles.lastCheckedText, textStyle]}>
      {` ‚Ä¢ ${formatTimeAgo(url.lastChecked)}`}
    </Text>
  )}
</View>

{/* Display additional information */}
{url.checkHistory && url.checkHistory.length > 0 && (
  <>
    <Text style={[styles.responseTimeText, textStyle]}>
      Response:{' '}
      {
        url.checkHistory[url.checkHistory.length - 1]
          .responseTime
      }
      ms
      {url.checkHistory[url.checkHistory.length - 1]
        .statusCode &&
        ` ‚Ä¢ Status: ${
          url.checkHistory[url.checkHistory.length - 1]
            .statusCode
        }`}
    </Text>
    {url.checkHistory[url.checkHistory.length - 1]
      .isRedirect && (
      <Text style={[styles.redirectText, textStyle]}>
        ‚Ü™ Redirected
      </Text>
    )}
    {url.checkHistory[url.checkHistory.length - 1]
      .errorMessage && (
      <Text style={[styles.errorText, { color: '#F44336' }]}>
        ‚ö†{' '}
        {
          url.checkHistory[url.checkHistory.length - 1]
            .errorMessage
        }
      </Text>
    )}
  </>
)}
</View>
<TouchableOpacity onPress={() => removeUrl(url.id)}>
<Text style={styles.removeText}>Remove</Text>
</TouchableOpacity>
</View>
))}

{urls.length === 0 && (
<Text style={[styles.emptyText, textStyle]}>No URLs added yet</Text>
)}
</View>

{/* Callback Configuration */}
<View style={cardStyle}>
<Text style={[styles.sectionTitle, textStyle]}>
Callback Configuration
</Text>
<TextInput
style={inputStyle}
placeholder="Callback Name"
placeholderTextColor={isDarkMode ? '#999' : '#666'}
value={callbackConfig.name}
onChangeText={text =>
setCallbackConfig(prev => ({ ...prev, name: text }))
}
/>
<TextInput
style={[inputStyle, styles.marginTop]}
placeholder="Callback URL (e.g. webhook.site/...)"
placeholderTextColor={isDarkMode ? '#999' : '#666'}
value={callbackConfig.url}
onChangeText={text =>
setCallbackConfig(prev => ({ ...prev, url: text }))
}
autoCapitalize="none"
autoCorrect={false}
/>
<TouchableOpacity
style={[styles.button, styles.marginTop]}
onPress={saveCallbackConfig}
>
<Text style={styles.buttonText}>Save Callback</Text>
</TouchableOpacity>

{/* Last Callback Info */}
{lastCallback && (
<View style={styles.callbackHistory}>
<Text style={[styles.callbackHistoryTitle, textStyle]}>
Last Callback:
</Text>
<Text style={[styles.callbackHistoryText, textStyle]}>
Time: {formatDateTime(lastCallback.timestamp)}
</Text>
<Text style={[styles.callbackHistoryText, textStyle]}>
Total URLs: {lastCallback.totalUrls} (
<Text style={{ color: '#4CAF50', fontWeight: 'bold' }}>
  {lastCallback.activeCount} active
</Text>
,{' '}
<Text style={{ color: '#F44336', fontWeight: 'bold' }}>
  {lastCallback.inactiveCount} inactive
</Text>
)
</Text>
<Text style={[styles.callbackHistoryText, textStyle]}>
Sent:{' '}
<Text
  style={{
    color: lastCallback.success ? '#4CAF50' : '#F44336',
    fontWeight: 'bold',
  }}
>
  {lastCallback.success ? 'Success' : 'Failed'}
</Text>
</Text>

{/* Show all URLs in last callback */}
<View style={styles.urlListContainer}>
<Text style={[styles.urlListTitle, textStyle]}>URLs:</Text>
{lastCallback.urls.map((urlInfo, index) => (
  <View key={index} style={styles.urlListItem}>
    <View
      style={[
        styles.urlListIndicator,
        {
          backgroundColor:
            urlInfo.status === 'active' ? '#4CAF50' : '#F44336',
        },
      ]}
    />
    <Text
      style={[styles.urlListText, textStyle]}
      numberOfLines={1}
    >
      {urlInfo.url}
    </Text>
    {urlInfo.error && (
      <Text style={[styles.urlErrorText, { color: '#F44336' }]}>
        ({urlInfo.error})
      </Text>
    )}
  </View>
))}
</View>
</View>
)}
</View>

{/* Check Interval Settings */}
<View style={cardStyle}>
<Text style={[styles.sectionTitle, textStyle]}>
Check Interval Settings
</Text>

<View style={styles.inputRow}>
<TextInput
style={[inputStyle, styles.intervalInput]}
placeholder="Interval (minutes)"
placeholderTextColor={isDarkMode ? '#999' : '#666'}
value={checkInterval}
onChangeText={setCheckInterval}
keyboardType="numeric"
/>
<TouchableOpacity style={styles.button} onPress={saveInterval}>
<Text style={styles.buttonText}>Set Interval</Text>
</TouchableOpacity>
</View>

{/* Background Service Tips for Android */}
{Platform.OS === 'android' && (
<View style={styles.androidTips}>
<Text style={[styles.androidTipsTitle, textStyle]}>
üí° Background Service Tips:
</Text>
<Text style={[styles.androidTipsText, textStyle]}>
‚Ä¢ Grant all permissions when prompted
</Text>
<Text style={[styles.androidTipsText, textStyle]}>
‚Ä¢ Disable battery optimization in Settings
</Text>
<Text style={[styles.androidTipsText, textStyle]}>
‚Ä¢ Lock app in Recent Apps (swipe & tap lock icon)
</Text>
<Text style={[styles.androidTipsText, textStyle]}>
‚Ä¢ Keep persistent notification visible
</Text>
</View>
)}
</View>

{/* Manual Check Button */}
<TouchableOpacity
style={[styles.checkButton, isLoading && styles.buttonDisabled]}
onPress={() => checkAllUrls(false)}
disabled={isLoading || urls.length === 0}
>
{isLoading ? (
<ActivityIndicator color="white" />
) : (
<Text style={styles.checkButtonText}>Check All URLs Now</Text>
)}
</TouchableOpacity>

{/* Info Note */}
<View style={styles.infoNote}>
<Text style={[styles.infoNoteText, textStyle]}>
‚ÑπÔ∏è NetGuard Pro uses react-native-background-actions for true
background monitoring.
{'\n\n'}
üîÑ Background service runs independently from the app
{'\n'}
üì± Persistent notification shows service status
{'\n'}
üîã Optimized for battery efficiency
{'\n'}
üì° Works even when app is closed or device is locked
</Text>
</View>
</View>

{/* API Callback Selection Modal */}
<Modal
visible={showAPIModal}
animationType="slide"
transparent={true}
onRequestClose={() => setShowAPIModal(false)}
>
<View style={styles.modalOverlay}>
<View
style={[
styles.modalContent,
{ backgroundColor: isDarkMode ? '#2a2a2a' : 'white' },
]}
>
<Text style={[styles.modalTitle, textStyle]}>Select Callback</Text>

<FlatList
data={apiCallbackNames}
keyExtractor={item => item}
renderItem={({ item }) => (
<TouchableOpacity
  style={styles.modalItem}
  onPress={() => loadURLsForCallback(item)}
>
  <Text style={[styles.modalItemText, textStyle]}>{item}</Text>
  <Text style={[styles.modalItemCount, textStyle]}>
    {apiData.filter(d => d.callback_name === item).length} URLs
  </Text>
</TouchableOpacity>
)}
style={styles.modalList}
/>

<TouchableOpacity
style={styles.modalCloseButton}
onPress={() => setShowAPIModal(false)}
>
<Text style={styles.modalCloseButtonText}>Cancel</Text>
</TouchableOpacity>
</View>
</View>
</Modal>
</ScrollView>
);
}

const styles = StyleSheet.create({
container: {
flex: 1,
},
content: {
padding: 16,
paddingBottom: 32,
},
header: {
alignItems: 'center',
marginBottom: 20,
},
title: {
fontSize: 28,
fontWeight: 'bold',
},
lastCheckText: {
fontSize: 12,
opacity: 0.7,
marginTop: 4,
},
backgroundStatsText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
color: '#2196F3',
},
card: {
borderRadius: 12,
padding: 16,
marginBottom: 16,
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.1,
shadowRadius: 3.84,
elevation: 5,
},
serviceActiveCard: {
backgroundColor: '#E8F5E9',
borderColor: '#4CAF50',
borderWidth: 1,
},
serviceInactiveCard: {
backgroundColor: '#FFEBEE',
borderColor: '#F44336',
borderWidth: 1,
},
serviceHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 8,
},
serviceTitle: {
fontSize: 16,
fontWeight: '600',
flex: 1,
},
serviceDescription: {
fontSize: 14,
opacity: 0.8,
marginBottom: 4,
},
serviceUptime: {
fontSize: 12,
opacity: 0.7,
marginBottom: 4,
},
countdownText: {
fontSize: 14,
fontWeight: 'bold',
color: '#2196F3',
},
statsGrid: {
flexDirection: 'row',
justifyContent: 'space-around',
marginTop: 12,
},
statItem: {
alignItems: 'center',
},
statValue: {
fontSize: 20,
fontWeight: 'bold',
},
statLabel: {
fontSize: 12,
opacity: 0.7,
marginTop: 4,
},
lastServiceCheck: {
fontSize: 12,
opacity: 0.7,
marginTop: 8,
textAlign: 'center',
},
sectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 12,
},
sectionTitle: {
fontSize: 18,
fontWeight: '600',
},
clearText: {
color: '#F44336',
fontSize: 14,
fontWeight: '600',
},
networkInfoContainer: {
marginBottom: 12,
},
networkRow: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 8,
},
networkLabel: {
fontSize: 14,
fontWeight: '500',
width: 80,
},
networkValue: {
fontSize: 16,
fontWeight: '600',
flex: 1,
},
connectionStatus: {
flexDirection: 'row',
alignItems: 'center',
},
connectionIndicator: {
width: 10,
height: 10,
borderRadius: 5,
marginRight: 8,
},
refreshButton: {
backgroundColor: '#2196F3',
paddingHorizontal: 16,
paddingVertical: 8,
borderRadius: 6,
alignSelf: 'flex-start',
},
refreshButtonText: {
color: 'white',
fontSize: 14,
fontWeight: '600',
},
input: {
borderRadius: 8,
padding: 12,
fontSize: 16,
},
inputRow: {
flexDirection: 'row',
alignItems: 'center',
},
urlInput: {
flex: 1,
marginRight: 8,
},
intervalInput: {
flex: 1,
marginRight: 8,
},
addButton: {
backgroundColor: '#2196F3',
paddingHorizontal: 20,
paddingVertical: 12,
borderRadius: 8,
},
button: {
backgroundColor: '#4CAF50',
paddingHorizontal: 20,
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
},
buttonText: {
color: 'white',
fontWeight: '600',
fontSize: 16,
},
checkButton: {
backgroundColor: '#FF9800',
padding: 16,
borderRadius: 12,
alignItems: 'center',
marginTop: 20,
},
checkButtonText: {
color: 'white',
fontWeight: 'bold',
fontSize: 18,
},
buttonDisabled: {
opacity: 0.6,
},
urlItem: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
paddingVertical: 12,
borderBottomWidth: 1,
borderBottomColor: '#e0e0e0',
},
urlInfo: {
flex: 1,
marginRight: 12,
},
urlText: {
fontSize: 14,
marginBottom: 4,
},
statusRow: {
flexDirection: 'row',
alignItems: 'center',
},
statusIndicator: {
width: 8,
height: 8,
borderRadius: 4,
marginRight: 6,
},
statusText: {
fontSize: 12,
textTransform: 'capitalize',
},
lastCheckedText: {
fontSize: 11,
opacity: 0.7,
},
responseTimeText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
},
redirectText: {
fontSize: 11,
opacity: 0.6,
marginTop: 2,
color: '#FF9800',
},
errorText: {
fontSize: 11,
marginTop: 2,
},
removeText: {
color: '#F44336',
fontSize: 14,
fontWeight: '600',
},
emptyText: {
textAlign: 'center',
marginVertical: 20,
opacity: 0.6,
},
marginTop: {
marginTop: 12,
},
callbackHistory: {
marginTop: 16,
padding: 12,
backgroundColor: 'rgba(0,0,0,0.05)',
borderRadius: 8,
},
callbackHistoryTitle: {
fontSize: 14,
fontWeight: '600',
marginBottom: 4,
},
callbackHistoryText: {
fontSize: 12,
marginBottom: 2,
},
urlListContainer: {
marginTop: 8,
paddingTop: 8,
borderTopWidth: 1,
borderTopColor: 'rgba(0,0,0,0.1)',
},
urlListTitle: {
fontSize: 12,
fontWeight: '600',
marginBottom: 4,
},
urlListItem: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 2,
paddingVertical: 2,
},
urlListIndicator: {
width: 6,
height: 6,
borderRadius: 3,
marginRight: 6,
},
urlListText: {
fontSize: 11,
flex: 1,
},
urlErrorText: {
fontSize: 10,
marginLeft: 4,
},
androidTips: {
marginTop: 12,
padding: 10,
backgroundColor: 'rgba(33, 150, 243, 0.1)',
borderRadius: 8,
},
androidTipsTitle: {
fontSize: 14,
fontWeight: '600',
marginBottom: 4,
},
androidTipsText: {
fontSize: 12,
opacity: 0.8,
marginLeft: 12,
marginTop: 2,
},
infoNote: {
marginTop: 20,
padding: 12,
backgroundColor: 'rgba(33, 150, 243, 0.1)',
borderRadius: 8,
},
infoNoteText: {
fontSize: 12,
textAlign: 'center',
opacity: 0.8,
lineHeight: 18,
},
apiButtonsRow: {
flexDirection: 'row',
marginTop: 12,
gap: 8,
},
apiButton: {
backgroundColor: '#9C27B0',
paddingHorizontal: 16,
paddingVertical: 10,
borderRadius: 8,
flex: 1,
alignItems: 'center',
},
selectedCallbackText: {
fontSize: 14,
marginTop: 8,
fontStyle: 'italic',
},
modalOverlay: {
flex: 1,
backgroundColor: 'rgba(0, 0, 0, 0.5)',
justifyContent: 'center',
alignItems: 'center',
},
modalContent: {
width: '90%',
maxHeight: '70%',
borderRadius: 12,
padding: 20,
elevation: 5,
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.25,
shadowRadius: 3.84,
},
modalTitle: {
fontSize: 20,
fontWeight: 'bold',
marginBottom: 16,
textAlign: 'center',
},
modalList: {
maxHeight: 400,
},
modalItem: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
paddingVertical: 12,
paddingHorizontal: 16,
borderBottomWidth: 1,
borderBottomColor: 'rgba(0, 0, 0, 0.1)',
},
modalItemText: {
fontSize: 16,
flex: 1,
},
modalItemCount: {
fontSize: 14,
opacity: 0.6,
marginLeft: 8,
},
modalCloseButton: {
marginTop: 16,
backgroundColor: '#F44336',
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
},
modalCloseButtonText: {
color: 'white',
fontSize: 16,
fontWeight: '600',
},
});

export default App;
